# Collaboration with version control {#version_control}

```{r 04-setup_version_control, echo = FALSE, message = FALSE, warning = FALSE}
library(knitr)
library(magrittr)
library(magick)
knitr::opts_chunk$set(echo = FALSE)
```

## Overview
This chapter will introduce the concept of using version control systems to track changes to a project over
its lifespan, to share and edit code in a collaborative team, and to distribute the finished project to its intended audience.
This chapter also demonstrates how to implement these ideas effectively 
in practice using [Git](https://git-scm.com), [GitHub](https://github.com), and JupyterHub.

## Chapter learning objectives
By the end of the chapter, students will be able to:

- Describe what version control is and why data analysis projects can benefit from it
- Create a remote version control repository on GitHub
- Move changes to files from GitHub to JupyterHub, and from JupyterHub to GitHub
- Give collaborators access to the repository
- Resolve conflicting edits made by multiple collaborators
- Communicate with collaborators using issues
- Use best practices when collaborating on a project with others

## What is version control, and why should I use it?

Data analysis projects often require iteration and revision to move from an initial idea 
to a finished product that is ready for the intended audience. Without 
deliberate and conscious effort towards tracking changes made to the analysis, 
projects tend to become messy, with mystery results files that cannot be reproduced,
temporary files with snippets of ideas, mind-boggling filenames like `document_final_draft_v5_final.txt`,
large blocks of commented code "saved for later," and more. Additionally,
the iterative nature of data analysis projects makes it important to be able to examine
earlier versions of code and writing. Finally, data analyses are typically completed by a team of 
people rather than a single person. This means that files need to be 
shared across multiple computers, and multiple people often end up editing the project
simultaneously. In such a situation, determining who has the latest version of the project---and
how to resolve conflicting edits---can be a real challenge.

Version control helps solve these challenges by tracking changes to the files in the 
analysis (code, writing, data, etc) over the lifespan of the project, including when the changes were made and who made 
them. This provides the means both to view earlier versions of the project and to revert changes.
Version control also facilitates collaboration via tools to share edits with others and resolve conflicting edits. 
But even if you're working on a project alone, you should still use version control.
It helps you keep track of what you've done, when you did it, and what you're planning to do next!
 
> *You mostly collaborate with yourself, and me-from-two-months-ago never responds to email.*
> 
> --Mark T. Holder

In order to version control a project, you generally need two things: a *version control system* 
and a *repository hosting service*. The version control system is the software that is responsible 
for tracking changes, sharing changes you make with others, obtaining changes others have made, and resolving conflicting edits.
The repository hosting service is responsible for storing a copy of the version controlled project online, 
where you and your collaborators can access it remotely, discuss issues and bugs, and distribute your final product. 
For both of these items, there is a wide variety of choices; some of the more popular ones are:

- **Version control systems:**
    - [Git](https://git-scm.com) 
    - [Mercurial](https://mercurial-scm.org)
    - [Subversion](https://subversion.apache.org)
- **Repository hosting services:**
    - [GitHub](https://github.com)
    - [GitLab](https://gitlab.com)
    - [BitBucket](https://bitbucket.org)

In this textbook we'll use Git for version control, and GitHub for repository hosting.

> **Note:** technically, you don't *need* a repository hosting service. You can, for example, use Git to version control a project
> that is stored only in a folder on your computer. But using a repository hosting service provides a few big benefits, including managing collaborator access permissions,
> tools to discuss and track bugs, and the ability to have external collaborators contribute work, not to mention the safety of having your work backed up in the cloud. Since most
> repository hosting services now offer free accounts, there are not many situations in which you wouldn't want to use one for your project. 


## Creating a space to share your code online

[GitHub](https://github.com/) is an example of a remote version control 
repository and Internet hosting service that software developers, and data 
scientists use to archive and share their projects. It has controls that allow
users to selectively share their work at various levels of permissions with 
collaborators as well as your project's intended audience. It interfaces with 
local version control systems on a laptop or JupyterHub server, so that files 
(including ones that contain code!) can be easily transferred and shared. 
Projects live in GitHub in a space called a repository. We will demonstrate now 
how to create such a space on for your data analysis project.

> Other examples of remote version control repository and Internet hosting 
> services include [GitLab](https://gitlab.com/) and 
> [Bitbucket](https://bitbucket.org/). Here we will focus on GitHub because it is 
> currently the most widely-used platform.

Before you can create repositories, you will need a 
[GitHub](https://github.com/) account. You can sign up for a free account 
here: [https://github.com/](https://github.com/)

To create new repository to host your project, Login to 
[https://github.com/](https://github.com/) and click on the "+" icon in the upper right 
hand corner, and then click on "New Repository" as shown below:

```{r new_repository_01}
#include_graphics("img/version_control/new_repository_01.png")
image_read("img/version_control/new_repository_01.png") %>% 
  image_flop() %>% 
  image_crop("3632x1148") %>% 
  image_flop() #%>% 
  #image_shadow()
```

On the next page, do the following: 

- enter the name for the repository (here we put `languages_in_canada`) 
- Select "Public"
- Select "Initialize this repository with a README"
- click on the green "Create Repository" button

> By clicking "Public" your repository is viewable by anyone, however, only you 
and any collaborators you specify have permission to create or edit files. If 
you have a project that needs to be kept private, you can instead select 
"Private" when creating a repository.

```{r new_repository_02_old}
#include_graphics("img/version_control/new_repository_02.png")
image_read("img/version_control/new_repository_02.png") %>% 
  image_flop() %>% 
  image_crop("1700x2296+1000-150") %>% 
  image_flop() #%>% 
  #image_shadow()
```

Now you should have a repository that looks something like this:

```{r new_repository_03}
image_read("img/version_control/new_repository_03.png") %>% 
  image_flop() %>% 
  image_crop("3632x1700") %>% 
  image_flop() 
```


## Edit and add materials in your course repository on GitHub

There are several ways you can directly use the GitHub web interface; either 
using the pen tool to edit existing files, or the “Add file” drop down where you 
can choose to "Create new file" or "Upload files". This is useful for simple 
documentation files, for example a project's `README.md` file.


### Use the pen tool to edit existing files

The pen tool can be used to edit existing plain text files. Click on the pen 
tool:

```{r pen_tool_01}
image_read("img/version_control/pen-tool_01.png") %>% 
  image_flop() %>% 
  image_crop("3632x1500") %>% 
  image_flop() #%>% 
  #image_shadow()
```

Use the text box to make your changes:

```{r pen_tool_02}
image_read("img/version_control/pen-tool_02.png") %>% 
  image_flop() %>% 
  image_crop("3632x1300") %>% 
  image_flop() #%>% 
  #image_shadow()
```

Save/commit your changes by click the green "Commit changes" button:

```{r pen_tool_03}
image_read("img/version_control/pen-tool_03.png") %>% 
  image_crop("3632x1500+1+500") #%>% 
  #image_shadow()
```


### Use the "Add file" drop down menu and "Create new file" to create new plain text files

New, plain text files can be created via the "Add file" drop down menu and 
selecting the "Create new file" option:

```{r create_new_file_01}
image_read("img/version_control/create-new-file_01.png") %>% 
  image_flop() %>% 
  image_crop("3632x1600") %>% 
  image_flop() #%>% 
  #image_shadow()
```

After click the "Create new file" option, a page will open with a small text box 
for the file name to be entered, and a larger text box where the desired file 
content text can be entered. Note the two tabs, "Edit new file" and "Preview". 
Toggling between them lets you enter and edit text and view what the text will 
look like when rendered, respectively.

```{r create_new_file_02}
image_read("img/version_control/create-new-file_02.png") %>% 
  image_flop() %>% 
  image_crop("3632x1300") %>% 
  image_flop() #%>% 
  #image_shadow()
```

Save/commit your changes by click the green "Commit changes" button at the 
bottom of the page.

```{r create_new_file_03}
image_read("img/version_control/create-new-file_03.png") %>% 
  image_crop("3632x1500+1+500") #%>% 
  #image_shadow()
```


### Use the "Add file" drop down menu and "Upload files" to get files from my laptop to GitHub

You can also upload files that you have created on your local machine by using 
the "Add file" drop down menu and selecting "Upload files":

```{r upload_files_01}
image_read("img/version_control/upload-files_01.png") %>% 
  image_flop() %>% 
  image_crop("3632x1600") %>% 
  image_flop() #%>% 
  #image_shadow()
```

To select the files from your local computer to upload, you can either drag and 
drop them into the grey box area shown below, or click the "choose your files" 
link to access a file browser dialog. Once the files you want to upload have 
been selected, click the green "Commit changes" button at the bottom of the 
page.

```{r upload_files_02}
image_read("img/version_control/upload-files_02.png") %>% 
  image_flop() %>% 
  image_crop("3632x2300") %>% 
  image_flop() #%>% 
  #image_shadow()
```


## Moving changes from GitHub to JupyterHub

Although there are several ways to create and edit files on 
[GitHub](https://github.com/) they are not quite powerful enough for 
efficiently creating and editing complex files, or files that need to be 
executed to assess whether they work (e.g., files containing code). Thus, it is 
useful to be able to connect the project repository that was created on 
[GitHub](https://github.com/) to a coding environment. This can be done on 
your local computer, or using a JupyterHub. Given that we use a JupyterHub with 
this course, we will here show how to do this using a JupyterHub.


To bring a copy of our [GitHub](https://github.com/) project repository to 
a JupyterHub, copy the url from the HTTPS tab of the Code drop down menu on 
[GitHub](https://github.com/) to your computer's clipboard:

```{r clone_02}
image_read("img/version_control/clone_02.png") %>% 
  image_crop("3632x1500")
```

Then from JupyterHub, click the Git+ icon on the file browser tab:

```{r clone_01}
image_read("img/version_control/clone_01.png") %>% 
  image_crop("2400x1430+1")
```

Paste the url of the [GitHub](https://github.com/) project repository you 
created and click the blue "CLONE" button:

```{r clone_03}
image_read("img/version_control/clone_03.png") %>% 
  image_crop("2400x1430+1")
```

On the file browser tab, you will now see a folder for your project's repository 
(and inside it will be all the files that existed on 
[GitHub](https://github.com/)):

```{r clone_04}
image_read("img/version_control/clone_04.png") %>% 
  image_crop("2400x1430+1")
```

## Sending changes you make on JupyterHub back to GitHub

Once you make changes, by creating or editing files, in your project repository 
on JupyterHub, you will need to send them back to the project repository on 
[GitHub](https://github.com/) to be able to share these with your 
collaborators and audience. Again, we can use the Jupyter lab Git extension tool 
to do this. It is a three stage process which includes: 

1. Specifying which files to "add" to the staging area. You can think of this as
a command which flags which modified files you want to send back to the project 
repository on [GitHub](https://github.com/).
2. Logging the changes to the flagged files on the local machine (which for us 
is a JupyterHub). This step requires specifying an associated (useful) message 
about what was changed. This step is called a "commit".
3. Push the added and committed changes that currently exist locally (i.e., on 
JupyterHub) to the project repository on [GitHub](https://github.com/)

Below we walk-through how you can use the Jupyter lab git extension tool to do 
each of the steps outlined above.

### Specifying which files whose changes you want to commit

Below we created and saved a new file (named `eda.ipynb`) that we would 
like to send back to the project repository on [GitHub](https://github.com/). 
To "add" this modified file to the staging area (*i.e.*, flagging that this is a
file whose changes we would like to log), we click the Jupyter lab git extension 
icon on the far left-hand side of Jupyter lab:

```{r git_add_01}
image_read("img/version_control/git_add_01.png")
```

This opens the Jupyter lab Git graphical user interface (GUI) pane, and then we
click the plus sign beside the file that we want to "add". Note, because this is 
the first change for this file that we want to add, it lives under the 
"Untracked" heading. However, next time we edit this file and want to add the 
changes we made, we will find it under the "Changed" heading.

> Note: we can ignore the `eda-checkpoint.ipynb` file (sometimes called `.ipynb_checkpoints`), as it can be thought of as another type of "back-up" of 
our Jupyter notebook file we created, and we only need to send the file we 
directly created and edited to [GitHub](https://github.com/).

```{r git_add_02}
image_read("img/version_control/git_add_02.png")
```

This moves the file from the "Untracked" heading to the "Staged" heading, 
essentially flagging this file, so that Git knows this is a change we'd like to 
log and share with others. Now we are ready to now "commit" the changes to log 
them and associate a (useful) message about what was changed.

```{r git_add_03}
image_read("img/version_control/git_add_03.png")
```

### Log the changes and an associated (useful) message about what was changed

To log the changes and an associated (useful) message about what was 
changed, we put our message in the text box at the bottom of the Git GUI pane 
and click on the blue "Commit" button. 

> It is highly recommended to write useful and meaningful messages about what 
was changed, as these commit messages, and the time date stamp for a given 
commit, are the primary means to navigate through our projects histry in the 
situation where we'd like to view or retrieve a past version of a file, or 
revert our project to an earlier state.

```{r git_commit_01}
image_read("img/version_control/git_commit_01.png")
```

> When you click the "Commit" button for the first time, you will be prompted to 
> enter your name and email. This only needs to be done once for each machine 
> you use Git on.

After "commiting" the file(s), you will see there there are 0 "Staged" files and we 
are now ready to push our changes (and the attached commit message) to our 
project repository on [GitHub](https://github.com/):

```{r git_commit_03}
image_read("img/version_control/git_commit_03.png")
```

#### 3. Pushing the changes to [GitHub.com](https://github.com/)

To send our added and committed the changes to the project repository on 
[GitHub](https://github.com/), we need to "Push" them. To do this we click on 
the cloud icon with the up arrow on the Jupyter Git tab:

```{r git_push_01}
image_read("img/version_control/git_push_01.png")
```

We will then be prompted to enter our [GitHub](https://github.com/) username 
and password, and click the blue "OK" button:

```{r git_push_02}
image_read("img/version_control/git_push_02.png")
```

If the files were successfully pushed to our project repository on 
[GitHub](https://github.com/) we will be given the success message shown 
below. Click "Dismiss" to continue working in Jupyter.

```{r git_push_03}
image_read("img/version_control/git_push_03.png")
```

If you now go to the project repository on [GitHub](https://github.com/) you 
will see the changes now exist there!

```{r git_push_04}
image_read("img/version_control/git_push_04.png") %>% 
  image_crop("3632x2000")
```

## Strategies for collaboration when using version control

### Giving collaborators access to your project

As mentioned earlier, GitHub allows you to control who has access to your 
project. The default of both public and private projects are that only the 
person who created the GitHub repository has permissions to create, edit and 
delete files (this is called write access). To give others (i.e., your 
collaborators) write access to the projects, navigate to the "Settings" tab:

```{r add_collab_01}
image_read("img/version_control/add_collab_01.png") %>% 
  image_crop("3632x1250")
```

Then click "Manage access":

```{r add_collab_02}
image_read("img/version_control/add_collab_02.png") %>% 
  image_crop("3632x1200")
```

And then click the green "Invite a collaborator" button:

```{r add_collab_03}
image_read("img/version_control/add_collab_03.png") %>% 
  image_crop("3632x2200")
```

Type in the collaborator's GitHub username and select their name when it 
appears:

```{r add_collab_04}
image_read("img/version_control/add_collab_04.png") %>% 
  image_crop("3632x1250")
```

Finally, click the green "Add <COLLABORATORS_GITHUB_USER_NAME> to this repository" button:

```{r add_collab_05}
image_read("img/version_control/add_collab_05.png") %>% 
  image_crop("3632x1250")
```

After this you should see your newly added collaborator listed under the 
"Manage access" tab, and they should receive an email invitation to join the 
GitHub repository as a collaborator. They need to accept this invitation via 
their email invitation to enable their ability to have and use write access.

### Pulling changes from [GitHub](https://github.com/)

If your collaborators send changes to your project and you want to see and work
with them locally (i.e., on JupyterHub) then you need to "pull" those changes to 
the copy of the project repository on JupyterHub to get things in sync. 

```{r git_pull_00}
image_read("img/version_control/git_pull_00.png") %>% 
  image_crop("3632x1900")
```
You can do this using the JupyterHub Git tab by clicking on the cloud icon with 
the down arrow:

```{r git_pull_01}
image_read("img/version_control/git_pull_01.png")
```

Once the files are successfully pulled from GitHub, you need to click "Dismiss"
to keep working:

```{r git_pull_02}
image_read("img/version_control/git_pull_02.png")
```

And then when you open (or refresh) the files whose changes you just pulled,
you should be able to see them:

```{r git_pull_03}
image_read("img/version_control/git_pull_03.png")
```

It can be very useful to review the history of the changes to your project, you
can do this directly on the JupyterHub by clicking "History" in the Git tab.

```{r git_pull_04}
image_read("img/version_control/git_pull_04.png")
```

It is good practice when collaborating with others, that you pull any changes 
your collaborators might have pushed to GitHub at the start of every work 
session. If you do not do this, and your collaborators have pushed some changes
to the project to GitHub, then you will be unable to push your changes to 
GitHub. This situation can be recognized by this error message:

```{r merge_conflict_01}
image_read("img/version_control/merge_conflict_01.png") %>% 
  image_crop("3632x1900")
```

Usually, getting out of this situation is not too troublesome. First you need to 
pull the changes that exist on GitHub that you do not yet have on your machine.
Usually when this happens, Git can  automatically merge the changes for you, 
even if you and your collaborators were working on different parts of the same 
file!

If however, you and your collaborators made changes to the same line of the same
file, Git will not be able to automatically merge the changes when you pull 
them, as it will not know whether to keep your version of the line(s), your 
collaborators version of the line(s), or some blend of the two. When this 
happens, Git will tell you that you have a merge conflict and that it needs 
human intervention (you!), and which file(s) this occurs in.

```{r merge_conflict_03}
image_read("img/version_control/merge_conflict_03.png") %>% 
  image_crop("3632x1900")
```

### Handling merge conflicts

To fix the merge conflict we need to open the file that had the merge 
conflict in a plain text editor and look for special marks that Git puts in the
file to tell you where the merge conflict occurred. 

```{r merge_conflict_04}
image_read("img/version_control/merge_conflict_04.png") %>% 
  image_crop("3632x1200")
```

The beginning of the merge
conflict is preceded by `<<<<<<< HEAD` and the end of the merge conflict is 
marked by `>>>>>>>`. Between these markings, Git also inserts a separator 
(`=======`). The version of the change before the separator is your change, and 
the version that follows the separator was the change that existed on GitHub.

```{r merge_conflict_05}
image_read("img/version_control/merge_conflict_05.png") %>% 
  image_crop("3632x1200")
```

Once you have decided which version of the change to keep, you need to use the 
plain text editor to remove the special marks that Git added to tell you where 
the merge conflict was, as well as edit the changes so that only a single 
version of the change is left in the file (either your version, your 
collaborator's version, or some blend of the two). 

```{r merge_conflict_06}
image_read("img/version_control/merge_conflict_06.png") %>% 
  image_crop("3632x1200")
```

The file must be saved, and then added and committed before you will be able to 
push the changes to GitHub.

### Communicating using GitHub issues

When communicating with collaborators regarding ideas, feedback, decisions and 
other such things about the project, what communication platform should be used
for written communication? At first glance, email and messaging apps appear to 
be reasonable choices, but both have flaws that can lead to loss of information
and non-inclusive team dynamics. 

Email has become a standard written communication platform which is ubiquitously
used, however, in many cases, much human intervention is required to keep emails
correctly filed and archived so that it is easy to go back and review all past 
written communications related to a particular project. Additionally, when 
working in a team on a project, it is easy to unintentionally leave someone off
of a team email, and as a consequence some team members can miss out on 
important information and decision-making opportunities for the project. 

Many messaging apps, allow for channels, where all team members are invited, and thus
leaving someone out of a conversation is less likely, however, organizing 
conversations into topics within a project channel, as well as searching for 
past conversations is usually quite challenging in these apps, as they were not 
designed for these purposes.

GitHub issues are an alternative written communication medium to email and 
messaging apps, and were designed specifically to facilitate project-level 
communication. GitHub issues are created from the issues tab in the project's
GitHub repository, and they persist there even after the issue is closed (in 
contrast to email, issues are not deleted). One issue thread is usually created
per topic, and they are easily searchable using GitHub's search tools. All 
issues are accessible to all project collaborators, so no one is left out of 
the conversation. Finally, issues can be setup so that team members get email 
notifications when a new issue is created, or a new post is made in an issue 
thread - so adding another notification system is not needed. Replying to issues 
from email is also possible. Thus, due to all of these advantages for 
project-level communication, we highly recommend their use for all written
project-related communications with collaborators.

To open a GitHub issue, first click on the GitHub issues tab:

```{r issue_01}
image_read("img/version_control/issue_01.png") %>% 
  image_crop("3632x1250")
```

Next click new issue:

```{r issue_02}
image_read("img/version_control/issue_02.png") %>% 
  image_crop("3632x1250")
```

Add an issue title (which acts like an email subject line), and then put the 
written communication in the larger text box. Finally click "Submit new issue"
to post the issue to share with others:

```{r issue_03}
image_read("img/version_control/issue_03.png") %>% 
  image_crop("3632x2500")
```

You can reply to an issue that someone opened by adding your written response to
the large text box and clicking comment:

```{r issue_04}
image_read("img/version_control/issue_04.png") %>% 
  image_crop("3632x2000")
```

When a conversation is resolved, you can click "Close issue", and closed issue 
can be later viewed be clicking "Closed" header link in the issue tab:

```{r issue_06}
image_read("img/version_control/issue_06.png") %>% 
  image_crop("3632x1900")
```
