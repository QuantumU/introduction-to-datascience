[
["version-control.html", "Chapter 5 Using Version control for collaboration 5.1 Overview 5.2 Chapter learning objectives 5.3 What is version control and why should I use it? 5.4 Creating a space to share your code online 5.5 Moving changes from GitHub to JupyterHub 5.6 Sending changes you make on JupyterHub back to GitHub 5.7 Strategies for collaboration when using version control", " Chapter 5 Using Version control for collaboration 5.1 Overview This chapter will introduce the concept of tracking changes to a project over the project’s lifespan using version control, as well as strategies for effectively collaborating with others. This chapter also demonstrates how to use version control tool (Git and GitHub) with JupyterHub to track changes to a data science project over time, as well as share code with collaborators and the project’s intended audience. 5.2 Chapter learning objectives By the end of the chapter, students will be able to: Describe what version control is and why data analysis projects can benefit from using it Create a remote version control repository on GitHub.com Move changes to files from GitHub to JupyterHub, and from JupyterHub to GitHub Use best practices for collaboration when using version control to collaborate on a project with others 5.3 What is version control and why should I use it? Good data analysis projects require iteration and revision to move from project ideation, through proof-of-concept to a finished product that is ready to be communicated to the intended audience. Without deliberate and conscious effort towards tracking which version of the analysis code led to which version of the results, data analysis projects can quickly and easily become messy, and the results irreproducible. Additionally, the iterative nature of data analysis projects means that there are usually several times in a project where one would like to go back to an earlier version of a code file, or back in time to an earlier state of the project to experiment or test things. Finally, data analysis projects are rarely completed by a single person alone, and instead teams of people typically collaborate. This means that files need to be shared across multiple computers, and multiple people usually end up editing a single file. In such a situation, determining which version of that file is the latest and most up to date can be a challenge - especially when two people are working on the same file at once! Version control helps solve these challenges in analysis projects, particularly those that involve code, by tracking changes to code and data over the lifespan of a project (including when the changes were made and who made them). Version control also provides means to retreive earlier versions of a file (or files), or even go back in time to earlier states of the project. Finally, it also facilitates the merging changes from different collaborators working on the project - even when they are working on the same file (Wilson et al. 2014)! You might find yourself saying, but I am not collaborating, so I don’t need to use or learn version control. However, as this popular data science quote aptly points out, future you often has to collaborate with past you. You mostly collaborate with yourself, and me-from-two-months-ago never responds to email – Mark T. Holder 5.4 Creating a space to share your code online GitHub is an example of a remote version control repository and Internet hosting service that software developers, and data scientists use to archive and share their projects. It has controls that allow users to selectively share their work at various levels of permissions with collaborators as well as your project’s intended audience. It interfaces with local version control systems on a laptop or JupyterHub server, so that files (including ones that contain code!) can be easily transferred and shared. Projects live in GitHub in a space called a repository. We will demonstrate now how to create such a space on for your data analysis project. Other examples of remote version control repository and Internet hosting services include GitLab and Bitbucket. Here we will focus on GitHub because it is currently the most widely-used platform. Before you can create repositories, you will need a GitHub.com account. You can sign up for a free account here: https://github.com/ To create new repository to host your project, Login to GitHub.com and click on the “+” icon in the upper right hand corner, and then click on “New Repository” as shown below: On the next page, do the following: enter the name for the repository (here we put dsci-101) Select “Public” Select “Initialize this repository with a README” click on the green “Create Repository” button By clicking “Public” your repository is viewable by anyone, however, only you, and any collaborators you specify have permission to create or edit files. If you have a project that needs to be kept private, you can instead select “Private” when creating a repository. Now you should have a repository that looks something like this: 5.5 Moving changes from GitHub to JupyterHub Although there are several ways to create and edit files on GitHub.com they are not quite powerful enough for efficiently creating and editing complex files, or files that need to be executed to assess whether they work (e.g., files containing code). Thus, it is useful to be able to connect the project repository that was created on GitHub.com to a coding environment. This can be done on your local computer, or using a JupyterHub. Given that we use a JupyterHub with this course, we will here show how to do this using a JupyterHub. Git is the software the does the job of tracking changes to a project, as well as the moving of a project (and it’s history) across different machines. Like many other kinds of software, we as the users have to tell Git how and when to do this. Git commands can be directly entered into a terminal/command line, however there are many Git clients that make this process more user friendly. For this book, we will use the Jupyter lab Git extension tool as our Git client. To bring a copy of our GitHub.com project repository to a JupyterHub, from the JupyterHub click the Git+ icon on the file browser tab: Paste the url of the GitHub.com project repository you created and click the blue “CLONE” button: On the file browser tab, you will now see a folder for your project’s repository (and inside it will be all the files that existed on GitHub.com): 5.6 Sending changes you make on JupyterHub back to GitHub Once you make changes (e.g., create or edit files) in your project repository on JupyterHub, you will need to send them back to the project repository on GitHub.com to be able to share these with your collaborators and audience. Again, we can use the Jupyter lab Git extension tool to do this. It is a three stage process which includes: Specifying which files to “add” to the staging area. You can think of this as a command which flags which modified files you want to send back to the project repository on GitHub.com. Logging the changes to the flagged files on the local machine (which for us is a JupyterHub). This step requires specifying an associated (useful) message about what was changed. This step is called a “commit”. Push the added and committed changes that currently exist locally (i.e., on JupyterHub) to the project repository on GitHub.com Below we walk-through how you can use the Jupyter lab git extension tool to do each of the steps outlined above. 5.6.1 Specifying which files whose changes you want to commit Below we created and saved a new file (named eda.ipynb) that we would like to send back to the project repository on GitHub.com. To “add” this modified file to the staging area (i.e., flagging that this is a file whose changes we would like to log), we click the Jupyter lab git extension icon on the far left-hand side of Jupyter lab: This opens the Git graphical user interface (GUI) pane, and then we click the plus sign beside the file that we want to “add”. Note, because this is the first change for this file that we want to add, it lives under the “Untracked” heading. However, next time we edit this file and want to add the changes we made, we will find it under the “Changed” heading. Note: we can ignore the eda-checkpoint.ipynb file (sometimes called .ipynb_checkpoints), as it can be thought of as another type of “back-up” of our Jupyter notebook file we created, and we only need to send the file we directly created and edited to GitHub.com. This moves the file from the “Untracked” heading to the “Staged” heading and we are ready to now “commit” the changes to log them and associate a (useful) message about what was changed. 5.6.2 Log the changes and an associated (useful) message about what was changed To log the changes and an associated (useful) message about what was changed, we put our message in the text box at the bottom of the Git GUI pane and click on the blue “Commit” button. Note: It is highly recommended to make this message useful and relevant to the changes that were made, as this can later be used to peruse the file history and understand how the file evolved. This is especially useful when you want to go back in time to checkout an older version of a file, or state of the project. After “commiting” the file(s), you will see there there are 0 “Staged” files and we are now ready to push our changes (and the attached commit message) to our course repository on GitHub.com: 5.6.2.1 3. Pushing the changes to GitHub.com To send our added and committed the changes to the project repository on GitHub.com, we need to “Push” them. To do this we click on the cloud icon with the up arrow on the Git GUI pane: We will then be prompted to enter our GitHub.com username and password, and click the blue “OK” button: If the files were successfully pushed to our course repository on GitHub.com we will be given the success message shown below. Note: click “Dismiss” to continue working in Jupyter. If you now go to the project repository on GitHub.com you will see the changes now exist there! 5.7 Strategies for collaboration when using version control 5.7.1 Pulling changes from GitHub.com If your collaborators send changes to your project and you want to see and work with them locally (i.e., on JupyterHub) then you need to “pull” those changes to the copy of the project repository on JupyterHub to get things in sync. You can do this using the Git GUI pane by clicking on the cloud icon with the down arrow: 5.7.2 Handling merge conflicts TBD References "]
]
